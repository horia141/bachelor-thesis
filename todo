+ change all test modules to use 8'bxxxxxxxx instead of 8'h00 in cases where the value
  of the immediate constant for a instruction doesn't matter.

+ change inst_wen to inst_en.

* investigate relationship between next and n_Address and c_Address in Seq.

x add proper tests for Rom16x12.

x add proper error handling in SeqAsm
  x check all instructions are valid
  x check modules fit in memory
  x check a module imports only names exported by another module
  x check a module exports only defined names, or names imported from another module (optionally, 
    since this will be harder to do for our compiler).
  x check an imported module exists. currently, a lot of this logic (last three points) exists in findName.
  x check in import conflicts (two modules imported with the same name or aliases).

x add proper source string information to SeqSourceInfo by way of (take (length sourceInit - length sourceLast) sourceInit)

x remove evalExpr from exports and imports where it shouldn't belong.

x if it's beginning to be an issue, change the underlying generated type from String, to
 (String,Integer) or something similar. The String is still the generated value, but the Integer
 is used for calculations.

x see issues with negative numbers in SeqAsm.

x too much lingake between modules in SeqAsm. Basically, only Main should link
  the different modules. Parser or Compiler should not have access to Primitives,
  for example - functions from them should be parametrized accordingly.

x remove Seq prefix for SeqAsm type names.

* add a Dev tool that generates .sav files from compact representations.

* add a way to represent in the Makefiles the fact that some Dev tools are used by the makefile itself, and every rule should depend on them, as well as not use them in their building process.

+ in all build rules, when creating the gen "database", we should structure variables by tool, rather than just dump them at the root of Gen as we do now.

+ add a Prj|Dev.$(1).Gen.OutFile representing the final output of a rule.

* integrate Program into Makefile.

* rethink build system. Our current system should provide the base but : we need to integrate separate targets and target actions into a project (So we no longer have Auto1.Sim and Auto1.FPGA etc., but just Auto1 with different targets and actions) AND we need to make available the option to build just all sim or all fpga actions for every target (to cut down in development time by omitting lengthy fpga build procedures) AND we need to make mock files for build actions (these would be useful to avoid building large actions when no changes occur) AND we need to integrate Program into all of this AND we need to rely less on built-in logic for targets (ideally we would have a file specifying each project, the targets and actions supported, as well as optional arguments, misc configurations etc., another file that describes targets and their actions and what files they make use of AND the makefile that ties these all together and provides a nice framework. In this configuration, you would have a target, with a number of actions. Each action should describe in a standard manner, which external scrips should be run and in what order. These external scripts would then provide the specific logic (for example, in the FPGA.Build rule, we would have scripts for each tool (making directories, creating command files, running the tool and finally moving resulting files to proper positions), and the Makefile framework would make sure to call them as the FPGA.Build action specifies).

* if we still have propagation errors and combinatorial loops even with more complex designs (that fully generate a circuit) I should investigate chaning the design to use module outputs linked to c_ signals instead of n_ signals. Such a module is basically a Moore machine (outputs depend only on the current state c_) whereas what we have now is a Mealy machine (outputs depend on the current state and on inputs, and in our specific case, they depend only on inputs, since n_ signals are combinatorial derivations of the inputs), and, because of their nature, will make the designs more robust in the presence of hazards as well as able to scale to higher clock frequencies. The only downside is a more complex execution model (outputs from a controller apear at time t+d, are registered at (t+1) by a slave, and the slave's output appears at (t+1)+d and the controller can work with it at (t+2)). It's worth investigating using multiple clocks (either two clocks in oposition, or four clocks in quadrature) and linking the master to a clock, and all slaves to a opposite clock. The main problem here is working with deep hierarchies where a master, has several slaves, each slave containing a master and slaves configuration as well.

* make *Sim modules more uniform : a test of all instructions, a inst_en test, a error state test and custom tests. use PushBtnBankSim as a model. Eliminate #0 delays because they are not the same as no delay :|.

* change Btn to Button or Button to Btn everywhere in the button modules.

* add a pertarget Def field where specific defines are set per-target.

: the gimp can output .c or .h files with the contents of an image.

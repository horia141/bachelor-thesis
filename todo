+ change all test modules to use 8'bxxxxxxxx instead of 8'h00 in cases where the value
  of the immediate constant for a instruction doesn't matter.

+ change inst_wen to inst_en.

+ investigate relationship between next and n_Address and c_Address in Seq.
/ by changing to a more synchronous design, all outputs are derived from c_ or i_ signals, which represent the current state, and not the next one.

x add proper tests for Rom16x12.

x add proper error handling in SeqAsm
  x check all instructions are valid
  x check modules fit in memory
  x check a module imports only names exported by another module
  x check a module exports only defined names, or names imported from another module (optionally, 
    since this will be harder to do for our compiler).
  x check an imported module exists. currently, a lot of this logic (last three points) exists in findName.
  x check in import conflicts (two modules imported with the same name or aliases).

x add proper source string information to SeqSourceInfo by way of (take (length sourceInit - length sourceLast) sourceInit)

x remove evalExpr from exports and imports where it shouldn't belong.

x if it's beginning to be an issue, change the underlying generated type from String, to
 (String,Integer) or something similar. The String is still the generated value, but the Integer
 is used for calculations.

x see issues with negative numbers in SeqAsm.

x too much lingake between modules in SeqAsm. Basically, only Main should link
  the different modules. Parser or Compiler should not have access to Primitives,
  for example - functions from them should be parametrized accordingly.

x remove Seq prefix for SeqAsm type names.

* add a Dev tool that generates .sav files from compact representations.

* add a way to represent in the Makefiles the fact that some Dev tools are used by the makefile itself, and every rule should depend on them, as well as not use them in their building process.

+ in all build rules, when creating the gen "database", we should structure variables by tool, rather than just dump them at the root of Gen as we do now.

+ add a Prj|Dev.$(1).Gen.OutFile representing the final output of a rule.

* integrate Program into Makefile.

* rethink build system. Our current system should provide the base but : we need to integrate separate targets and target actions into a project (So we no longer have Auto1.Sim and Auto1.FPGA etc., but just Auto1 with different targets and actions) AND we need to make available the option to build just all sim or all fpga actions for every target (to cut down in development time by omitting lengthy fpga build procedures) AND we need to make mock files for build actions (these would be useful to avoid building large actions when no changes occur) AND we need to integrate Program into all of this AND we need to rely less on built-in logic for targets (ideally we would have a file specifying each project, the targets and actions supported, as well as optional arguments, misc configurations etc., another file that describes targets and their actions and what files they make use of AND the makefile that ties these all together and provides a nice framework. In this configuration, you would have a target, with a number of actions. Each action should describe in a standard manner, which external scrips should be run and in what order. These external scripts would then provide the specific logic (for example, in the FPGA.Build rule, we would have scripts for each tool (making directories, creating command files, running the tool and finally moving resulting files to proper positions), and the Makefile framework would make sure to call them as the FPGA.Build action specifies).

+ if we still have propagation errors and combinatorial loops even with more complex designs (that fully generate a circuit) I should investigate chaning the design to use module outputs linked to c_ signals instead of n_ signals. Such a module is basically a Moore machine (outputs depend only on the current state c_) whereas what we have now is a Mealy machine (outputs depend on the current state and on inputs, and in our specific case, they depend only on inputs, since n_ signals are combinatorial derivations of the inputs), and, because of their nature, will make the designs more robust in the presence of hazards as well as able to scale to higher clock frequencies. The only downside is a more complex execution model (outputs from a controller apear at time t+d, are registered at (t+1) by a slave, and the slave's output appears at (t+1)+d and the controller can work with it at (t+2)). It's worth investigating using multiple clocks (either two clocks in oposition, or four clocks in quadrature) and linking the master to a clock, and all slaves to a opposite clock. The main problem here is working with deep hierarchies where a master, has several slaves, each slave containing a master and slaves configuration as well.
/ changed to a more synchronous design, and specified in the todo body.

* change Seq,Alu,Swc and all "small name modules" to larger names: Sequencer, ArithmeticalLogicalUnit, StopWatchCounter etc.

+ make *Sim modules more uniform : a test of all instructions, a inst_en test, a error state test and custom tests. use PushBtnBankSim as a model. Eliminate #0 delays because they are not the same as no delay :|.
/ the change to a more synchronous design required a rewrite of all test cases.

+ change Btn to Button or Button to Btn everywhere in the button modules.

* add a pertarget Def field where specific defines are set per-target.

+ change RDL and RDR Rotary instructions to RLS and RRS (Read Left Status etc.).
/ changed all explicit read instructions to RD* and all load instructions to LD*.

+ Standardize RD for reading something and LD for loading something. for PushBtn : RDBS and for Rotary RDLS and RDRS.
/ changed all explicit read instructions to RD* and all load instructions to LD*.

+ add a more compact human readable representation of components internal state.
/ added in the form of d_Input and s_State debug strings.

+ change w_* variables to be like s_* variables in naming by using camel case.

* upgrade build infrastructure to set Xilinx environment variables on an invocation basis, and not rely on them being in the user's .bashrc file. Also, check ilinxusb script and, in general, make it possible, just to have a copy of the xilinx tools places somewhere, and, with no other configuration, make the build process work.

+ make all modules respect format : clock & reset then instructions & other inputs then outputs.

+ all test comments end with a comma.

+ resolve all labels in the *.mem files to addresses in the comments.
/ changed format to a table-like one and aligned all input,output and address codes to 4 bits.

* in new build system, add rules for generating installable packages of the system (all Xilinx Tools + all simulation tools + ghc and all needed packgaes) which I can distrubute and which are standalone development environments (just execute an install script and the system is installed : in a single directory and doesn't mess your system in any way !!! (this is important for org. freaks like me :)). Also, a rule for backup packages (only actual code, no tools) and for atually doing a backup (mail it to an email address).

* make all modules respect format : clocks & reset, instruction & other inputs, outputs, outside world inputs, outside world outputs.

* add per-project defines in makefile which are "-D"-ed into source files.

* DdrCtl1 error should let the module continue refreshing etc. and after reset and error recovery the memory shouldn't be reinitialized.

* add an annotations Instruction ROM for simulations. This should hold the assembler source of an instruction.

* add commands to DdrCtl1 to select which byte of the 4 byte page is selected for output.

* remove extra wait state in AutoRefresh action for the core state machine in DdrCtl1, if testing reveals that it isn't necessary (and it shouldn't be at our speed).

* for the seqasm tool, add a stage for testing the validity of the input data. Test ideeas:
    * the fact that all opcodes fit into the allowed bits (for both sequencers and components)
    * the fact that all sequencers have enough bits to command each device (ComponentCommandSize >= component.CommandSize).
    * check that, in the device file, every component appears at the outputs.

: for the seqasm tool, core concepts are the fact that there is a stream of instructions which must be translated to a stream of bits, taking note of the system being targeted, the fact that there are certain elements useful in assembly only (labels, numbers, symbols etc.) and which have no meaning to the translated binary. Concepts which we take for granted ar the fact that there are instructions which must be translated into their binary equivalents, which take a number of arguments, which can be numbers (literals in different forms), labels, device instructions and device outputs. All translations from numbers to binary streams, from labels to binary streams, from device instructions to binary streams and from device ouputs to binary streams, are controlled by a Device.cfg file and a *.dev file (which together describe all sequencers and components and our particular system).

: the gimp can output .c or .h files with the contents of an image.

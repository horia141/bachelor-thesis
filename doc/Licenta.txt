Lucrarea de licență.

Studiu asupra procesoarelor cu arhitectura de transport. Exemple de aplicații.

1.Introducere.

2.Teorie generala.

Arhitectura de Transport, alaturi de Arhitectura von Neumann si Arhitectura Harvard, este un model pentru organizarea masinilor de calcul. Majoritatea realizarilor fizice ale acestor modele au fost, istoric, sub forma calculatoarelor digitale, iar discutia ce urmeaza va fi influentata de acest fapt. Modelul clasic, si discutabil, cel mai des folosit, este cel von Neumann. Vom numi un calculator ce adopta o astfel de arhitectura, un calculator von Neumann, procedand similar pentru celelalte doua tipuri de arhitecturi.

De notat, ca toate aceste modele pornesc de la premisele implementarii unei forme de Masina Turing. Aceste masini sunt entitati matematice, folosite de matematicieni in intelegerea procesului de calculare a unei functii, proces ce in acest caz este descris de un algoritm ce opereaza asupra unui set de date. Algoritmul este codificat si trebuie interpretat de o Masina Turing pentru a produce datele de iesire pornind de la o instanta specifica de date de intrare. O Masina Turing este alcatuita dintr-o banda de celule infinita si un cap de citire/prelucrare plasat deasupra unei celule specifice. Fiecare celula are inscrisa un simbol ales dintr-un alfabet finit. Masina este caracterizata de o stare curenta aleasa dintr-un alfabet finit si un set de reguli ce asociaza perechilor [stare,simbol] actiuni, ce pot produce o modificare a starii masinii, o deplasare a capului de citire pe banda sau o schimbare a simbolului inscris in celula curenta. Regula de functionare a masinii este urmatoarea: aceasta porneste intr-o stare initiala cu capul de citire plasat deasupra unei celule initiale si trebuie sa ajunga intr-una din starile finale (sau stari acceptante). Se produce modificarea specificata de regula asociata perechii initiale iar masina isi schimba starea si afecteaza intr-un mod banda. Dupa un timp (durata pasului de executie) se executa actiunea asociata noii perechi [stare,simbol]. Procesul continua in acest fel, din pas de executie in pas de executie, pana la schimbarea intr-o stare acceptanta, moment in care se spune ca algoritmul se incheie cu succes. Un concept important este acela ca algoritmul se executa intr-un anumit timp discretizat in pasi de executie. Timpul total este determinat de durata unui pas si de numarul de pasi executati. Cu alte cuvinte, un calcul nu se executa instantaneu, ci dureaza un anumit timp. Aceasta limitare duce la un model de computabilitate ce reflecta realitatea fizica (in primul rand existenta unor variatii minime in timp si spatiu care ar impiedica, in principiu, orice masina de calcul sa execute un algoritm instantaneu, constrangand durata unui pas de executie sa fie cel mult egala cu variatia temporala minima, iar apoi, in al doilea rand, limitarile dispozitivelor actuale ce inpun o alta categorie de constrangeri, mult mai dure (ordine de marime in timp si spatiu deasupra variatiilor minime)).

Arhitectura von Neumann presupune existenta unei Unitati de Procesare (UP) ce are acces la o Unitate de Stocare (US) si la un numar de dispozitive de Intrare/Iesire (DIO). Acest model mai este cunoscut si ca "Modelul de Calculator cu Program Stocat", el presupunand existenta in US atat a datelor de intrare cat si a descrierii algoritmului ce trebuie executat. Astfel se inglobeaza in US atat banda unei Masini Turing cat si setul de reguli ce descriu algoritmul. UP este astfel o componenta generica, independenta de vreun algoritm anume, si interactioneaza cu US pentru a obtine simbolurile ce descriu operatia de executat cat si datele pe care aceasta se va executa. Desi cele doua nu se refera conceptual la aceleasi lucruri, Masina Turing fiind folosita pentru descrierea abstracta a calculelor, pe cand Arhitectura von Neumann descriind cum o masina de calcul oarecare ar putea fi structurata, exista o legatura puternica intre cele doua, o Masina von Neumann fiind o realizare generica a unei Masini Turing. Mai mult, pe cand o Masina Turing este specifica fiecarei probleme (fiind descrierea algorimtului de rezolvare), Masina von Neumann este generala, specializarea pe o problema sau alta fiind realizata de catre o configuratie anume a US.

[Poza Arhitectura von Neumann]

Dupa cum spuneam, majoritatea masinilor de calcul sunt calculatoare digitale. Unitatea de Stocare este alcatuita dintr-un grup de memorii, avand ca unitatea de stocare fundamentala bitul. O masina de calculdigitala este caracterizata de numarul de biti cu care poate opera in paralel, acest numar reprezentand marimea cuvantului. Marimi standard sunt 4,8,16,32 si 64 de biti. Conceptul abstract de simbol cu care am lucrat pana acum in definirea Masinii Turing si a Masinii von Neumann este inlocuit de cuvant, o entitate numerica, folosita atat in codarea simbolurilor cat si ca atare (ca un numar). Fiind in domeniul practic, aceasta decizie este naturala pentru ca duce la o reprezentare usoara (un cuvant de N biti este reprezentat in memorie de N celule de stocare, are nevoie de N registrii pentru stocare in interiorul Unitatii de Procesare etc. - pe cand reprezentarea unui simbol : un nume pentru o entitate matemtatica, in definitiv, produce multe nedumeriri), dar, are dezavantajul ca presupune inglobarea in UP a unei unitati pentru lucrul cu numere. Aceasta se numeste Unitatea Aritmetico-Logica si este folosita in reprezentarea clasica a Masinilor von Neumann.

[Poza Arhitectura von Neumann clasica].

Practica a impus separarea Unitatii de Procesare intr-o Unitate de Control (UC) si o Unitate Aritmetico-Logica (UAL). UC indeplineste rolul pe care UP il indeplinea in modelul abstract, anume, aduce din US comenzi si date sub forma simbolica sau numerica, le interpreteaza, operand apoi schimbarile inapoi asupra US. Pentru as-i duce la bun sfarsit operatiile, UC face apel la UAL, multe dintre instructiunile unui calculator (si implicit, operatiile pe care le poate efectua) avand natura aritmetica.

Calculatoarele moderne pornesc de la acest model, adaugand diverse componente si extinzand modelul de baza, in principiu pentru a face fata problemelor lumii fizice. Un calculator actual personal poate avea urmatoarea structura (la un nivel foarte inalt).

[Poza Arithectura calculator clasica].

O observatie rapida ar fi ca pentru majoritatea programelor nu este nevoie decat de acces de citire la regiune de memorie in care este stocat codul programului (codificarea algoritmului). Pornind de la aceasta observatie, o alternativa la Arhitectura von Neumann este Arhitectura Harvard. Conceptual, presupune doar separarea US intr-o Unitate de Stocare pentru Program (USP) si o Unitate de Stocare pentru Date (USD), pastrand in rest caracteristicile von Neumann. Principalul avantaj al unei astfel de abordari este o crestere in viteza cauzata de separarea cailor fizice de transmisie intre UP si US in doua cai UP - USP si UP - USD. Se pot face accese la instructiuni concomitent cu accese de date, lucru foarte util in cazul foarte comun in care viteza de acces la memorie este mica (si deci nu exista dorinta de a avea multe accese spre acceasi memorie, ci multe accese spre memorii diferite). Mai mult, pentru multe aplicatii, programul ocupa un spatiu mult mai mic decat datele. Memoria necesara stocarii lui este mai mica, si poate fi situat mai aproape in ierarhia memoriilor de UP (poate chiar in acelasi microprocesor in care este gazduit si UP). In practica, multe dintre procesoarele construite pe baza arhitecturii von Neumann adopta principii Harvard, exemplul cel mai elocvent fiind existenta memoriilor cache separate pentru program si date aproape de UP, dar unificarea lor in memoria principala (si mentinerea iluziei unificarii).

[Poza Arhitectura calculator Harvard].

[Poza Arhitectura calculator modern evidentiand locurile unde e Harvard].

In spatiul modelelor pentru masini de calcul, Arhitecturile de Transport se situeaza undeva deasupra celor studiate pana acum. Intr-adevar, vom vedea ca arhiecturile de transport sunt folosite pentru structurarea sitemelor digitale in general, acest lucru neimplicand neaparat echivalenta sistemului cu o Masina Turing. Cateva dintre exemplele de aplicatii nu vor fi universale in acest sens.

Ce inseamna atunci, ca un calculator este o Masina de Transport? Pornind tot de la o Masina von Neumann, acest lucru presupune eliminarea UAL ca si unitate privilegiata. Din UP ramane doar partea de control (UC) alaturi de US. ALU este trecut in categoria dispozitivelor externe (DIO). Mai mult, asemeni masinilor Harvard, se adopta o separare a memoriei de program si a memoriei de date. USD trece alaturi de ALU in categoria dispozitivelor de iesire, iar USP ramane alaturi de UC ca unitate distincta. Astfel avem o stransa cuplare intre UP si USP si o cuplare intre UP si DIO. UP interactioneaza cu USP pentru obtinerea instructiunilor de control iar 

[Poza Arhitectura de Transport].

Ce ramane atunci efectiv din masina de calcul este un sistem programat ce controleaza transferurile intre unitati externe. Unitatile externe pot lua orice forma si pot fi combinate in orice fel. De aici si flexbilitatea de a face un sistem mai apropiat de cerintele aplicatiei. Depinzand de selectia de componente externe, sistemul poate si sau nu universal, dupa cum am mentionat.

[Poza Arhitectura de Transport #2]

Putem spune ca din setul de instructiuni ale unui calculator, intr-un astfel de sistem pastram doar instructiunile de control. Instructiunile artimetico-logice sunt elimiate, functiile lor realizandu-se de unitati externe. Instructiunea de baza este cea de control al transferului : aceasta spune ca la un pas de executie, continutul de la o intrare a UP sa fie transmis catre o iesire. Este singura instructiune necesara (este un exemplu de One Instruction Set Computer), pana si contorul de program putand fi reprezentat ca o componenta externa. Complexitatea ei variaza, putand fi conditionata de valoarea unei intrari sau a datei de transmis [1] sau putand specifica mai multe transferuri de efectuat in paralel.

Componentele externe joaca si ele un rol important. Ele isi efectueaza operatiile ca urmare a primirii unui transfer de la UP. Acesta este modul de programare. UP coordoneaza transferuri intre unitati. Datele primite de o componenta la intrare sunt procesate si prezentate la iesire, iar rezultatul este transferat catre intrarea unei alte componente samd. Dintre acestea enumeram : bancuri de registrii, numaratoare, dispozitive de interfata seriala/paralela, timere, memorii, interfete cu diverse componente externe calculatorului etc.

3.Prezentarea sistemului. Descriere componente. Unelte.

Pe partea practica, am realizat un set de unelte pentru constructia de aplicatii dedicate. Initial am dorit realizarea unui switch ethernet. Deoarece intreg procesul a fost unul didactic in principiu, ruta aleasa a fost putin diferita, de unde si aplicatiile exemple, si, in definitiv, toate elementele de infrastructura, si setul de unelte insasi.

Vorbesc aici efectiv despre ce am făcut eu. Enumăr realizările. Apoi vorbesc despre cele doua ținte : simularea și FPGA-ul. FPGA-ul este principalul mijloc de realizare, fac un rundown al sistemului de dezvoltare, enumăr limitări, avantaje etc. Trebuie sa vorbesc cumva și despre simulare. Eventual și despre mediul de build și unelte. Apoi încep sa vorbesc despre toolkit-ul ce îl construiesc. Ce înseamna secventiator, ce înseamna componenta, cum se leagă. Ideea ca pot fi combinate în fel și chip, configurate ca sa avem un sistem optim. O sa vorbesc despre modul comun de codare a secventiatoarelor și componentelor în verilog (cu exemplu). Și apoi sa vorbesc despre interfața lor, despre faptul ca au instrucțiuni, ca vreau sa fie toată faza de high-level design, și sa ca sa fie accesul cât mai simplu. Ca sa fie un fel de standard (o magistrala comuna pe care comunica toate astea), etc. Trebuie sa vorbesc despre un exemplu de secventiator : Seq, cu caracteristicile lui, și despre ce componente am realizat pana acum. Pun accent pe grupul Core (registrii, alu, swc, etc.) pe grupul de interfața (Butoane, Rotary, VGA etc.) și pe modulul de interfața cu memoria ddr (descriu cât de greu e și aja).

Exemple de aplicații.

În final vorbesc despre aplicații. Dau exemplele Auto2, RotaryLed, BlockFall etc. cu ce fac, programe, structura lor etc. etc.

Concluzii.

TODO:

* Sa vorbesc despre instructiuni. Cod etc. Dihotomie instructiuni de control al fluxului si instructiuni de operare asupra datelor.
* Sisteme, aplicatii.

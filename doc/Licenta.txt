Lucrarea de licență.

Studiu asupra procesoarelor cu arhitectura de transport. Exemple de aplicații.

1.Introducere.

2.Teorie generala.

Arhitectura de Transport, alaturi de Arhitectura von Neumann si Arhitectura Harvard, este un model pentru organizarea masinilor de calcul. Majoritatea realizarilor fizice ale acestor modele au fost, istoric, sub forma calculatoarelor digitale, iar discutia ce urmeaza va fi influentata de acest fapt. Modelul clasic, si discutabil, cel mai des folosit, este cel von Neumann. Vom numi un calculator ce adopta o astfel de arhitectura, un calculator von Neumann, procedand similar pentru celelalte doua tipuri de arhitecturi.

De notat, ca toate aceste modele pornesc de la premisele implementarii unei forme de Masina Turing. Aceste masini sunt entitati matematice, folosite de matematicieni in intelegerea procesului de calculare a unei functii, proces ce in acest caz este descris de un algoritm ce opereaza asupra unui set de date. Algoritmul este codificat si trebuie interpretat de o Masina Turing pentru a produce datele de iesire pornind de la o instanta specifica de date de intrare. O Masina Turing este alcatuita dintr-o banda de celule infinita si un cap de citire/prelucrare plasat deasupra unei celule specifice. Fiecare celula are inscrisa un simbol ales dintr-un alfabet finit. Masina este caracterizata de o stare curenta aleasa dintr-un alfabet finit si un set de reguli ce asociaza perechilor [stare,simbol] actiuni, ce pot produce o modificare a starii masinii, o deplasare a capului de citire pe banda sau o schimbare a simbolului inscris in celula curenta. Regula de functionare a masinii este urmatoarea: aceasta porneste intr-o stare initiala cu capul de citire plasat deasupra unei celule initiale si trebuie sa ajunga intr-una din starile finale (sau stari acceptante). Se produce modificarea specificata de regula asociata perechii initiale iar masina isi schimba starea si afecteaza intr-un mod banda. Dupa un timp (durata pasului de executie) se executa actiunea asociata noii perechi [stare,simbol]. Procesul continua in acest fel, din pas de executie in pas de executie, pana la schimbarea intr-o stare acceptanta, moment in care se spune ca algoritmul se incheie cu succes. Un concept important este acela ca algoritmul se executa intr-un anumit timp discretizat in pasi de executie. Timpul total este determinat de durata unui pas si de numarul de pasi executati. Cu alte cuvinte, un calcul nu se executa instantaneu, ci dureaza un anumit timp. Aceasta limitare duce la un model de computabilitate ce reflecta realitatea fizica (in primul rand existenta unor variatii minime in timp si spatiu care ar impiedica, in principiu, orice masina de calcul sa execute un algoritm instantaneu, constrangand durata unui pas de executie sa fie cel mult egala cu variatia temporala minima, iar apoi, in al doilea rand, limitarile dispozitivelor actuale ce inpun o alta categorie de constrangeri, mult mai dure (ordine de marime in timp si spatiu deasupra variatiilor minime)).

Arhitectura von Neumann presupune existenta unei Unitati de Procesare (UP) ce are acces la o Unitate de Stocare (US) si la un numar de dispozitive de Intrare/Iesire (DIO). Acest model mai este cunoscut si ca "Modelul de Calculator cu Program Stocat", el presupunand existenta in US atat a datelor de intrare cat si a descrierii algoritmului ce trebuie executat. Astfel se inglobeaza in US atat banda unei Masini Turing cat si setul de reguli ce descriu algoritmul. UP este astfel o componenta generica, independenta de vreun algoritm anume, si interactioneaza cu US pentru a obtine simbolurile ce descriu operatia de executat cat si datele pe care aceasta se va executa. Desi cele doua nu se refera conceptual la aceleasi lucruri, Masina Turing fiind folosita pentru descrierea abstracta a calculelor, pe cand Arhitectura von Neumann descriind cum o masina de calcul oarecare ar putea fi structurata, exista o legatura puternica intre cele doua, o Masina von Neumann fiind o realizare generica a unei Masini Turing. Mai mult, pe cand o Masina Turing este specifica fiecarei probleme (fiind descrierea algorimtului de rezolvare), Masina von Neumann este generala, specializarea pe o problema sau alta fiind realizata de catre o configuratie anume a US.

[Poza Arhitectura von Neumann]

Dupa cum spuneam, majoritatea masinilor de calcul sunt calculatoare digitale. Unitatea de Stocare este alcatuita dintr-un grup de memorii, avand ca unitatea de stocare fundamentala bitul. O masina de calculdigitala este caracterizata de numarul de biti cu care poate opera in paralel, acest numar reprezentand marimea cuvantului. Marimi standard sunt 4,8,16,32 si 64 de biti. Conceptul abstract de simbol cu care am lucrat pana acum in definirea Masinii Turing si a Masinii von Neumann este inlocuit de cuvant, o entitate numerica, folosita atat in codarea simbolurilor cat si ca atare (ca un numar). Fiind in domeniul practic, aceasta decizie este naturala pentru ca duce la o reprezentare usoara (un cuvant de N biti este reprezentat in memorie de N celule de stocare, are nevoie de N registrii pentru stocare in interiorul Unitatii de Procesare etc. - pe cand reprezentarea unui simbol : un nume pentru o entitate matemtatica, in definitiv, produce multe nedumeriri), dar, are dezavantajul ca presupune inglobarea in UP a unei unitati pentru lucrul cu numere. Aceasta se numeste Unitatea Aritmetico-Logica si este folosita in reprezentarea clasica a Masinilor von Neumann.

[Poza Arhitectura von Neumann clasica].

Practica a impus separarea Unitatii de Procesare intr-o Unitate de Control (UC) si o Unitate Aritmetico-Logica (UAL). UC indeplineste rolul pe care UP il indeplinea in modelul abstract, anume, aduce din US comenzi si date sub forma simbolica sau numerica, le interpreteaza, operand apoi schimbarile inapoi asupra US. Pentru as-i duce la bun sfarsit operatiile, UC face apel la UAL, multe dintre instructiunile unui calculator (si implicit, operatiile pe care le poate efectua) avand natura aritmetica.

Calculatoarele moderne pornesc de la acest model, adaugand diverse componente si extinzand modelul de baza, in principiu pentru a face fata problemelor lumii fizice. Un calculator actual personal poate avea urmatoarea structura (la un nivel foarte inalt).

[Poza Arithectura calculator clasica].

O observatie rapida ar fi ca pentru majoritatea programelor nu este nevoie decat de acces de citire la regiune de memorie in care este stocat codul programului (codificarea algoritmului). Pornind de la aceasta observatie, o alternativa la Arhitectura von Neumann este Arhitectura Harvard. Conceptual, presupune doar separarea US intr-o Unitate de Stocare pentru Program (USP) si o Unitate de Stocare pentru Date (USD), pastrand in rest caracteristicile von Neumann. Principalul avantaj al unei astfel de abordari este o crestere in viteza cauzata de separarea cailor fizice de transmisie intre UP si US in doua cai UP - USP si UP - USD. Se pot face accese la instructiuni concomitent cu accese de date, lucru foarte util in cazul foarte comun in care viteza de acces la memorie este mica (si deci nu exista dorinta de a avea multe accese spre acceasi memorie, ci multe accese spre memorii diferite). Mai mult, pentru multe aplicatii, programul ocupa un spatiu mult mai mic decat datele. Memoria necesara stocarii lui este mai mica, si poate fi situat mai aproape in ierarhia memoriilor de UP (poate chiar in acelasi microprocesor in care este gazduit si UP). In practica, multe dintre procesoarele construite pe baza arhitecturii von Neumann adopta principii Harvard, exemplul cel mai elocvent fiind existenta memoriilor cache separate pentru program si date aproape de UP, dar unificarea lor in memoria principala (si mentinerea iluziei unificarii).

[Poza Arhitectura calculator Harvard].

[Poza Arhitectura calculator modern evidentiand locurile unde e Harvard].

In spatiul modelelor pentru masini de calcul, Arhitecturile de Transport se situeaza undeva deasupra celor studiate pana acum. Intr-adevar, vom vedea ca arhiecturile de transport sunt folosite pentru structurarea sitemelor digitale in general, acest lucru neimplicand neaparat echivalenta sistemului cu o Masina Turing. Cateva dintre exemplele de aplicatii nu vor fi universale in acest sens.

Ce inseamna atunci, ca un calculator este o Masina de Transport? Pornind tot de la o Masina von Neumann, acest lucru presupune eliminarea UAL ca si unitate privilegiata. Din UP ramane doar partea de control (UC) alaturi de US. ALU este trecut in categoria dispozitivelor externe (DIO). Mai mult, asemeni masinilor Harvard, se adopta o separare a memoriei de program si a memoriei de date. USD trece alaturi de ALU in categoria dispozitivelor de iesire, iar USP ramane alaturi de UC ca unitate distincta. Astfel avem o stransa cuplare intre UP si USP si o cuplare intre UP si DIO. UP interactioneaza cu USP pentru obtinerea instructiunilor de control iar 

[Poza Arhitectura de Transport].

Ce ramane atunci efectiv din masina de calcul este un sistem programat ce controleaza transferurile intre unitati externe. Unitatile externe pot lua orice forma si pot fi combinate in orice fel. De aici si flexbilitatea de a face un sistem mai apropiat de cerintele aplicatiei. Depinzand de selectia de componente externe, sistemul poate si sau nu universal, dupa cum am mentionat.

[Poza Arhitectura de Transport #2]

Putem spune ca din setul de instructiuni ale unui calculator, intr-un astfel de sistem pastram doar instructiunile de control. Instructiunile artimetico-logice sunt elimiate, functiile lor realizandu-se de unitati externe. Instructiunea de baza este cea de control al transferului : aceasta spune ca la un pas de executie, continutul de la o intrare a UP sa fie transmis catre o iesire. Este singura instructiune necesara (este un exemplu de One Instruction Set Computer), pana si contorul de program putand fi reprezentat ca o componenta externa. Complexitatea ei variaza, putand fi conditionata de valoarea unei intrari sau a datei de transmis [1] sau putand specifica mai multe transferuri de efectuat in paralel.

Componentele externe joaca si ele un rol important. Ele isi efectueaza operatiile ca urmare a primirii unui transfer de la UP. Acesta este modul de programare. UP coordoneaza transferuri intre unitati. Datele primite de o componenta la intrare sunt procesate si prezentate la iesire, iar rezultatul este transferat catre intrarea unei alte componente samd. Dintre acestea enumeram : bancuri de registrii, numaratoare, dispozitive de interfata seriala/paralela, timere, memorii, interfete cu diverse componente externe calculatorului etc.

3.Prezentarea sistemului. Descriere componente. Unelte.

Din punct de vedere practic, am realizat un set de unelte pentru constructia de aplicatii dedicate, sub forma unor sisteme inspirate din ideile Arhitecturilor de Transfer. Exista un numar de diferente pe care le voi evidentia la momentul potrivit, dar sistemele astfel construite au anumite elemente imprumutate de la arhitecturile clasice, introduse pentru a face dezvoltarea aplicatiilor mai usoara. In jargonul de pana acum, am definit un numar de UC si DIO, cat si o metoda standard de dezvoltare si de interconectare, ce sunt asamblate, in functie de cerintele aplicatiei, in sisteme. Am numit UC-urile Secventiatoare (pentru ca ele controleaza secventa de operatiuni efectuate) si DIO-urile Componente. In plus, am dezvoltat un numar de sistme auxiliare, utile in procesul de constructie. Printre acestea se numara un asamblor pentru secventiatoare si un generator de memorii. Acestea au asociate formate de configurare si de program sursa specifice, pe care le voi documenta in subcapitolele aferente. De mare importanta este si mecanismul de construire propriu-zisa a sistemului, ce poate crea "binare" atat pentru sistemul de dezvoltare cat si pentru simulare.

Inainte de a intra in amanunte, trebuie sa facem un mic ocol si sa vorbesc despre sistemul de tinte de compilare si tintele definite. O tinta este sistemul cu care implementam aplicatia. De exemplu, daca avem o fabrica de realizare de chip-uri ASIC de mare volum, tinta ar fi procesul specific de realizare folosit in fabrica. Pentru a putea realiza o aplicatie in aceasta fabrica, treuie sa oferim fabricantului un numar de resurse (descriptii ale circuitelor digitale folosite in realizarea aplicatiei), intr-o forma oarecare (de obicei, fisire digitale text/binare), produse de un set de unelte specifice. Sistemul de construire se ocupa de transformarea descrierii aplicatiilor construite cu setul de unelte, in forma acceptata de tinta.

Momentan exista doua tinte. Cea mai simpla dintre acestea este simulatorul. Pentru simulare trebuie sa transformam descrierea aplicatiilor in reprezentari ale formelor de unda generate de circuitele implementate. Simulatorul este folosit pentru validarea si depanarea sistemelor si pentru dezvoltarea mai rapida a componentelor (compilarea pentru simulare dureaza mult mai putin decat cea pentru un sistem fizic).Pentru compilare folosim programele iverilog si vvp iar pentru vizualizare, programul gtkwave. 

[Imagine proces compilare pentru simulator | Imagine rezultat compilare]

A doua tinta este implementarea pe un chip FPGA. Mai precis, compilam pentru kitul de dezvoltare [nume kit aici] produs de firma Digillent. Componente principale sunt un chip FPGA Spartan3E [descriere tehnica] produs de Xilinx, o memorie DDR SDRAM [tip] Micron, o iesire VGA si un display LCD text [spune marca aici]. Sistemul mai ofera un numar de butoane si controale fizice, doua porturi seriale, porturi PS/2, convertoare analog-digital si digital-analog cat si pini de extensie. Un cristal genereaza un semnal ceas de 50Mhz. Toate implementarile vor opera la aceasta frecventa. Chip-ul FPGA este folosit pentru integrarea propriu-zisa a sistemelor. Tinta este definita nu doar de sistemul care implementeaza aplicatia propriu-zis (chip-ul FPGA) cat si de componentele periferice, modul lor de conectare la FPGA si parametrii de operare ai acesteia (ceasul de 50 MHz, posibilitatea de incarcare de configuratie pentru FPGA dintr-o memorie Flash etc.). In acest caz, pentru compilare, folosim setul de unelte pus la dispozitie de firma Xilinx.

[Imagine proces compilare pentru FPGA | Imagine rezultat compilare]

In viata reala avem o problema de rezolvat, o problema ce poate fi implementata ca un sistem digital. Exemple de probleme care se conformeaza definitiei anterioare sunt: un calculator de buzunar, un osciloscop digital, un calculator personal, un sistem de calcul dedicat (cum sunt cele pentru analiza tranzactiilor pe pietele de valuta sau pentru optimizari complexe) etc . Folosind setul de unelte dezvoltate, vrem sa cream o solutie pentru problema noastra. In jargonul sistemului, aceasta solutie se numeste o aplicatie.  Ea este alcatuita din unul sau mai multe nuclee de procesare impreuna cu logica de interconectare a acestora. In exemplele prezentate, regula este ca fiecare aplicatie are un singur nucleu, iar acolo unde sunt mai multe nuclee, metodele de interconectare sunt ad-hoc. Aceasta este o situatie departe de optim, si a survenit din cauza definirii tarzii in procesul de creatie a conceptului de aplicatie (inainte o aplicatie corespundea unui singur nucleu actual) iar intreaga logica de management a aplicatiilor nu este asa de bine reprezentata la nivelul uneltelor de constructie. Acest lucru va fi remediat in versiuni viitoare. Un nucleu este alcatuit dintr-un secventiator, un numar de componente si logica de interconectare a acestora. Exista un numar de legaturi spre lumea exterioara (care in implementarile actuale reprezinta legaturi spre componentele periferice atasate sistemului de dezvoltare sau modulele de test pentru simulator).

[Imagine aplicatie]

In centrul unui nucleu se afla un secventiator. Acesta este esenta un automat programat, ce are un numar de intrari si iesiri generice numite porturi, pentru interactiunea cu componentele comandate. Atasat de un secventiator este o sursa de program. Conectat la secventiator prin magistrale / logica de interconectare se afla componente. Exemple de componente sunt unitati aritmetico-logice, bancuri de registrii, timere si cronometre, memorii si, nu in ultimul rand, module intregi si sofisticate de interfata cu lumea externa (VGA,PS/2,serial,paralel,Ethernet,SDRAM etc.).

[Imagine nucleu detaliu]

Am prezentat un sistem folosind este o analiza de nivel-inalt. Pe masura ce setul de unelte se dezvolta, aceasta ar trebuii sa fie principalul mod de constructie al aplicatiilor. Codarea directa in Verilog ar trebuii pastrata pentru secventiatoare si componente, iar odata dezvoltata o librarie suficient de cuprinzatoare, un designer de sistem ar trebuii doar sa asambleze o aplicatie combinand secventiatoare si componente in nuclee si nuclee in aplicatia finita si nu ar trebuii sa se preocupe cu implementarea propriu-zisa a componentelor. Acesta este modelul pe care se dezvolta software-ul la scara mare in principiu, si care a dat rezultate bune de-a lungul timpului (in ceea ce priveste marimea proiectelor realizate). Momentan, in procesul de dezvoltare hardware, unealta de refolosire a proiectelor este nucleul IP (IP Core : Intelectual Property Core). Nivelul de abstractizare la care lucreaza o astfel de componenta este similara cu cel al unui nucleu in prezent setul de unelte. O paralela cu lumea dezvoltarii software ar plasa nucleele la acelasi nivel cu aplicatiile/programele, toate trei fiind unitati cu functii de anvergura si de granularitate mare (nu putem folosii doar jumatate din serverul Apache sau un sfert din make cand construim o solutie software). Continuand paralela, folosirea de secventiatoare si componente in interiorul unui nucleu este asemanatoare cu folosirea de librarii si functii in construirea unui program. Fiecare functie are un scop precis si granularitate mica. Acest lucru permite obtinerea de sisteme mai performante dar presupune o grija mai mare in procesul de asamblare. Ca exemplu ilustrativ din lumea software, pentru a accesa un document de pe un alt calculator prin intermediul http putem folosii o librarie de comunicare inter procese (bsdsockets) sau putem invoca un program dedicat (wget). Prima metoda ofera un control fin al implementarii si ne da posibilitatea de a optimiza performanta si consumul de resurse al programului, cat timp a doua metoda este usor de implementat si folosit. Fiecare metoda straluceste unde cealalta are probleme, dar, depinzand de situatie, fiecare este adecvata. Acesta este si modelul de folosire pe care il doresc pentru setul de unelte dezvoltat.

Secventiatorul este caracterizat de un numar de porturi de intrare si iesire, iar componentele de un port de comanda si mai multe porturi de iesire. Din punct de vedere al interconectarii de nivel-inalt (sa le spunem magistrale acestor conexiuni) acestea sunt singurele moduri in care se conecteaza sistemele. Portul de comanda al unei componente se leaga la un port de iesire al secventiatorului iar pe magistrala dintre cele doua se transmit comenzile. Formatul portului este comun tuturor componentelor. O parte este un cuvant de comanda, iar alta parte este argumentul comenzii. Semnificatia si formatul argumentului este determinat de tipul de comanda. Diverse porturi de iesire ale componentelor se pot lega ca intrari in secventiator. De exemplu, una dintre componentele ce vor fi prezentate implementeaza o unitate aritmetico-logica simpla. Ea are portul de comanda standard si un port de rezultat. Acesta se leaga la intrearea in secventiator, iar acesta are acces la rezultatul operatiilor comandate. Caracteristice pentru o componenta sunt marimea cuvantului de comanda (determina cate comenzi distincte se pot efectua) si marimea argumentului. Acestea determina si posibilitatile de interconectare (nu este indicat sa conectezi un secventiator la o componenta, cand acestea au marimi ale cuvantului, respectiv argumentului, diferite).

[Imagine componenta]

Caracteristici ale secventiatorului sunt marimea cuvantului, marimea spatiului de adrese, numarul de porturi de intrare si iesire, marimea portiunii de comanda din instructiune si marimea instructiunii propriu-zisa. Acestea impreuna cu setul de instructiuni descriu in mare parte un secventiator. Acesta opereaza dupa modelul traditional al unui microprocesor. La fiecare pas de executie (pasii de executie sunt dictati de ceasul sistemului) extrage instructiunea curenta din sursa de program (aceasta este determinata de adresa instructiunii curente (o parte din starea unui secventiator) dar nu numai), o decodeaza si executa fie transferurile codate, fie operatia de control (un salt sau o asteptare). Acestea sunt operatiile comune, dar setul de instructiuni, ca si parametrii de mai sus sunt specifici unei instante anume de secventiator, si in functie de situatie, pot fi instructiuni variate.

[Imagine secventiator]

O trasatura importanta este faptul ca la nivelul nucleului, interactiunea intre secventiator si componenta este standardizata. Fiecare componenta se leaga la secventiator in acelasi mod (o magistrala ce uneste portul de iesire al secventiatorului cu portul de comanda al componentei si mai multe magistrale ce unesc porturi de iesire ale componentei cu porturi de intrare ale secventiatorului) si expune un set de comenzi. Singura informatie ce trebuie in plus la momentul conectarii (iarasi, doar din punct de vedere al asamblarii high-level) este latenta intre executia unei operatii si obtinerea rezultatului. Pe scurt, in momentul design-ului sistemului, creatorul nu trebuie decat sa se preocupe ca nu acceseaza un rezultat prea devreme. Este o "suprafata de configurare" foarte mica, si faptul ca absolut toate componentele trebuie sa se conformeze, indiferent de complexitatea interna, ajuta, cred eu, la obtinrea unui proces foarte usor de creatie.

Privind o aplicatie dintr-un punct de vedere mai aproape de nivelul implementarii (circuite digitale si descrierea lor in Verilog), situatia este putin mai complexa. Exista o translatie a conceptelor din reprezentarea de nivel inalt in cea de nivel jos, ceea ce, fireste, ajuta procesul de dezvoltare. Pe langa aceasta, exista particularitati de care trebuie sa tinem cont. In primul rand, trebuie sa cream sisteme care sa poata fi realizate practic. Acest lucru presupune in principiu incadrarea in resursele sistemului de dezvoltare. Trebuie sa cream aplicatia tinand cont de aceste constrangeri : nu putem folosii un bloc de memorie de 3 Mb cand nu avem decat 320Kb in sistem; nu putem folosii o resursa periferica inexistenta etc. Apoi, codarea componentelor si a secventiatoarelor trebuie realizata in functie de resursele sistemului tinta si de realitatile descrierii unui circuit in Verilog (limitari ce tin in principiu de natura lucrurilor sintetizabile : nu orice idee exprimata in Verilog poate fi realizata ca si circuit). Apoi, componentele, secventiatoarele, nucleele, insasi aplicatia, sunt reprezentate de module Verilog. Trebuiesc definite legaturile intre acestea, care, pe langa magistralele din reprezentarea de nivel-inalt, mai contin semnale de ceas, diverse multiplexari ale unor semnale de comanda, legaturile si adaptarea lor propriu-zisa la semnalele catre componentele externe etc. In plus, mai trebuiesc reprezentate si componente fara o reprezentare de nivel inalt definita : momentan acestea sunt reprezentate de memorii de program pentru secventiatoare si memorii de date preinitializate.

3.1.Nuclee

3.1.1.Secventiatoare 

Dupa cum am spus, in centrul unui nucleu se afla secventiatorul. Momentan, exista un singur model implementat. Este un model ce opereaza pe cuvinte de 8 biti si cu un spatiu de adrese de 256 de instructiuni (8 biti de adresa in total). Marimea unei instructiuni este de 20 de biti. Spatiul de comenzi este de 16 instructiuni, dintre care doar 9 sunt folosite. Ca si arhitectura, este puternic inspirat din Arhitecturile de Transport. Functiile pe care le indeplineste sunt doar de control al transferului si de control al executiei. Operatii aritmetice, de acces la memorii etc. sunt lasate pe seama componentelor. De notat ca nu exista in realizarea sistemului de unelte vreo limitare in posibilitatile secventiatorului. Se pot adauga instructiuni (completand cu functiile traditionale ale unui microprocesor : adunari, scaderi, inmultiri etc.), sau, se pot indeparta, ramanand in limita calculatorelor conventionale, anume, folosirea unei singure instructiuni. Modelul actual, atat cu instructiuni de transfer, cat si cu instructiuni de control a executiei, a fost adoptat, in primul rand pentru usurinta cu care se dezvolta software pentru el (scrierea de programe este asemanatoare cu cea pentru calculatoare clasice), iar, in al doilea rand, pentru mentinerea unei puritati de design. Reducerea modulului de acces la memoria de program la statutul de componenta externa secventiatorului ar implica oarecum faptul ca aceasta are control asupra altor componente. Nu doream acest lucru, eu pastrand componentele independente unele de altele la nivel inalt. La nivelul implementarii sigur ca se influenteaza, chiar daca doar din cauza ca duc la consumarea unor resurse, limitate dealtfel.

[Imagine secventiator high-level | Imagine secventiator low-level]

[Instructiuni secventiator si tabel de formate]

O caracteristica a modeulului de secventiator implementat este ca nu este "Turing Complete". Are nevoie de un grup de componente pentru a fi. De obicei, o unitate aritmetico-logica simpla si un fel de memorie sunt deajunse. Acestea fiind spuse, multe aplicatii (in special sisteme de control simple) nu au nevoie de un microprocesor universal. In capitolul de exemple voi diferentia cele doua tipuri de aplicatii.

* Comenzi explicite; nu ne bazam pe treburi implicite.

* Stare: instruction pointer si logica de comanda.

* Porturi intrare iesire.

3.1.2.Componente

In aceasta sectiune am sa prezint componentele din libraria curenta. In principiu ele pot fi imparite in componente interne chip-ului FPGA si componente pentru interfata cu lumea exterioara. Componente din prima categorie sunt unitati aritmetico logice, bancuri de registrii, memorii interne etc. Componente din a doua categorie sunt unitati de interfata cu butoane de pe kit, unitatea de control VGA si unitatea de control a memoriei DDR. 

3.1.2.1.Unitatea aritmetico logica.

Aceasta componenta are rol de unitate aritmetico logica. Este bazata pe un model cu acumulator de ALU, astfel comenzile trimise opereaza folosind valoarea stocata in acumulator si argumentul trimis ca parametru al comenzii. Rezultatul este stocat in acumulator si accesibil secventiatorlui la inceputul pasului urmator. Comenzile ALU nu au latenta (deci programatorul poate executa oricate comenzi la viteza ceasului). Practic putem spune ca din punct de vedere al operatiilor artimetico logice un nucleu cu o astfel de unitate aritmetico logica executa 50 de milioane de operatii pe secunda.

[Imagine alu high level | Imagine alu low level]

[Tabel comenzi]

Operatiile implementate sunt cele aritmetice de baza : adunare, scadere, shiftare la stanga sau dreapta cu un bit; cele logice de baza: inversare, si, sau, sau-exclusiv; si cele relationale de baza: egalitate, inegalitate, mai mic strict, mai mic sau egal, mai mare strict si mai mare sau egal strict. Este un model simplu si a functionat in exemplele implementate. Functii complexe precum multiplicare, diviziunea sau suport pentru operatii in virgula mobila nu au fost introduse. Componente pentru astfel de operatii, si nu numai, pot fi, desigur adaugate.

Componenta are un port de iesire : "Result" ce poate fi conectat la un secventiator pentru a avea acess la rezultatul operatiilor.

[Imagine alu high-level conectat la secventiator | Imagine alu low level conectata la secventiator]

3.1.2.2.Bancul paralel de registrii.

Aceasta familie de componente (grupuri de 2,4 sau 8 registrii) are rolul "registrilor" din alte arhitecturi. Pana si acest concept este separat de cel de microprocesor. Depinzand de aplicatii se pot alege bancuri de marime corespunzatoare. Bancurile sunt, la fel ca si Unitatea Aritmetico Logica, interne chip-ului, si nu au latente vizibile in operatii.

[Imagine bancuri high-level | Imagine bancuri low-level]

[Tabel comenzi]

Depinzand de varianta aleasa pot fi 2,4 sau 8 porturi de iesire care pot fi legate la un secventiator. Cate o legatura pentru fiecare registru intern asigura o viteza de operare mai mare, dar ocupa si multe porturi ale secventiatorului (iar in cazul componentei cu 8 registre, acesta nici nu poate fi conectat in intregime la secventiatorul curent). 

[Imagine secventiator legat cu un banc de 4 registrii | low&high]

3.2.2.3.Bancul serial de registrii.

Similar cu bancul paralel de registrii, bancul serial ofera un acess de citire serial la 2,4 sau 8 registrii. Scrierile se fac in paralel (prin instructiuni separate), dar continutul fiecarui registru este multiplexat pe un singur port, iar iesirea este selectata printr-o instructiune separata. Un astfel de banc nu permite operare cu aceeasi viteza ca echivalentul paralel, dar consuma un singur port pentru secventiator. In cazul unei nevoi de bancuri mari cuplate cu secventiatoare mai mici, un atfel de banc este ideal.

[Imagine bancuri high-level | Imagine bancuri low-level]

[Tabel comenzi]

[Imagine bancuri de 4 legate la un secventiator]

3.2.2.4.Cronometrul.

Aceasta componenta este folosita pentru asteptarea unor perioade indelungate de timp. Astfel de componente sunt folosite in exemple pentru a putea prezenta evolutia sistemului la o viteza perceptibila de oameni. 

[Imagine cronometrul high-level | low-level]

[Tabel comenzi]

Cronometrul are o singura iesire, care indica daca numaratoarea s-a terminat sau nu (numaratoarea se termina la atingerea valorii 0).

[Imagine cronometru legat la un secventiator].

3.2.2.5.Bancul de leduri.

Discutabil cea mai simpla dintre componentele de interfata, daca nu dintre toate, bancul de leduri are rolul de a comanda cele 8 LED-uri de pe kitul de dezvoltare. Instructiuni permit incarcarea tuturor 8 sau cate unui bit pe rand. Cateva dintre exemple folosesc aceasta compoenta, iar in general, datorita simplitatii sale si a putinelor puncte unde poate avea probleme, poate fi folosita pentru depanare.

[Poza led-uri pe kit]

[Imagine bancul de leduri high-level | low-level]

[Tabel comenzi]

Bancul de leduri nu are niciun port de iesire, dar are legaturi de nivel jos spre cele 8 led-uri. Care pini sunt depinde de configuratia tintei (pentru simulare de exemplu nu se pune problema).

[Imagine banc de leduri legat la un secventiator si la porturile de iesire]

3.2.2.6.Unitatea de interfata cu butoane.

Unitatea de interfata cu butoanele imprastiate pe kit-ul de dezvoltare permite acces sigur al unui secventiator la "starea" unui buton. In mod normal, exista un traseu de legatura intre buton si chip-ul FPGA, terminat intr-un pin al acestuia, in asa fel incat la apasarea unui buton, nivelul semnalului primit este "0" logic, iar cand este liber, nivelul semnalului este "1". Datorita erorilor mecanice care apar la apasare, este nevoie de o componenta care sa filtreze semnalul. Unitatea de interfata cu butoane face acest lucru (pentru un singur buton) si, mai mult, asigura o stocare temporara pentru un singur eveniment de apasare (asa incat secventiatorul sa nu trebuiasca sa se ocupe la momentul aparitiei de eveniment). Exista memorie pentru un singur eveniment, asa ca o solutie mai sofisticata de buffering in software este necesara pentru sisteme mai complexe. Sistemele simple au o rata de producere a evenimentelor mult sub viteza de procesare a secventiatorului, asedar doar unitatea de interfata este necesara.

[Poza butoane pe kit]

[Imagine unitate de interfata cu butoane high|low].

[Tabel instructiuni]

Unitatea are un port de iesire, care contine rezultatul in urma instructiunii rdbs (anume, daca de la ultima apelare a lui rdbs s-a apasat butonul).

[Imagine unitate de interfata cu butoane legat la un secvenitator si porturile de iesire din dispozitiv]

Deoarece pot exista multe butoane, iar fiecare are nevoie de un port de intrare in secventiator, o solutie de legatura (mai sofisticata decat magistrala) este controlarea in paralel a mai multor unitati, si combinarea tuturor iesirilor de un bit, pana la marimea cuvantului secventiatorului, intr-un singur port de intrare. Toate intrebarile de stare se fac in paralel, deci avem si un bonus de viteza.

[Imagine unitati de interfata cu butoane comandate in paralel de acelasi secventiator]

3.2.2.7.Unitatea de interfata cu rotoare.

Pe kit-ul de dezvoltare se afla si un rotor. Unitatea de interfata cu rotorul adapteaza setul de semnale mai complex de la rotor intr-o forma cu care este usor de lucrat. Similar cu unitatea de interfata cu butoanele, are si rol de buffer pentru evenimente, putand stoca maxim un eveniment de rotire la stanga si unul de rotire la dreapta. Aceleasi consideratii de filtrare si performanta se pot face pentru rotor cum s-au facut pentru butoane.

[Poza rotor pe kit]

[Imagine unitate de interfata cu rotoare high|low].

[Tabel instructiuni]

Unitatea are doua porturi de iesire, unul pentru starea intrebarii in legatura cu evenimente de rotire la stanga, si, analog, unul pentru starea intrebarii in legatura cu evenimente de rotire la dreapta.

[Imagine unitate de interfata cu rotorul]

Similar, se pot unii aceste doua porturi si reduce cerintele de porturi de intrare in secventiator.

[Imagine unitate de interfata cu rotorul unita]

3.2.2.8.Unitatea de control VGA.

Aceasta componenta ofera unui secventiator echivalentul unui adaptor grafic de pe PC-uri. In primul rand creaza o interfata cu dispozitive compatibile standardului VGA (monitoare CRT, monitoare LCD etc.) si impune acestora o rezolutie de afisare de 800 de pixeli pe orizontala si 600 de pixeli pe verticala, cu o rata de improspatare a imaginii de 72Hz (setari alese ca sa se potriveasca perfect cu ceasul sistemului de 50Mhz : generarea de semnale VGA folosind aceste caracteristici necesita un ceas pixel de exact 50MHz). In al doilea rand ofera control asupra imaginii desenate printr-un mecanism framebuffer de 200 de pixeli pe orizontala si 150 de pixeli pe verticala cu 15 culori posibile. Dimensiunile mai mici (de 16 ori mai mici defapt : de 4 ori mai mic pe orizontala si 4 ori mai mic pe verticala) sunt cauzate de faptul ca sistemul de dezvoltare nu are suficienta memorie pentru a suporta marimea potrivita (anume 800x600) : design-ul acesta necesita 8 din 20 de unitati de memorie de 16Kb. 

Interfata fizica este un port VGA pe marginea kit-ului de dezvoltare. La acesta se conecteaza echipamente prin intermediul unor cabluri VGA cu conector tata.

[Imagine port VGA | Port VGA conectat]

De la port spre chip-ul FPGA exista 5 trasee, ce se conecteaza la 5 pini diferiti. Aceste legaturi transporta semnalele, in ordine, de sincronizare orizontala, de sincronizare verticala, componenta rosie a semnalului a semnalului de culoare, componenta verde a semnalului de culoare si componenta albastra a semnalului de culoare. Semnalele de sincronizare sunt digitale, in logica negativa, si controleaza secventa de cadre, respectiv linii in interiorul unui cadru (selectarea semnalului de sincronizare verticala determina terminarea cadrului, si repozitionarea tunului de electroni (din monitoarele CRT, sistemele care implementau original partea de afisare a standardului) in coltul de stanga-sus al ecranului, pe cand selectarea semnalului de sincronizare orizontala determina terminarea liniei, si repozitionarea tunului de electroni la inceputul urmatoarei linii). Semnalele de culoare sunt analogice si sunt interpretate de catre monitor ca transmitand informatia de intensitate pentru cele trei canale de culori, cu un pas de esantionare determinat de semnalele de sincronizare. Pe configuratia curenta de kit, semnalele acestea sunt controlate de pini digitali, deci singurele nivele posibile sunt de "0" sau "1". Aceasta situatie duce la posibilitatea reprezentarii doar a 8 culori (2^3). Original, acest lucru necesita 3 biti de memorie pentru reprezentarea fiecarui pixel din toti cei 200x150 din framebuffer. Pentru a putea reprezenta mai multe culori, folosim un procedeu numit dithering. Asociem inca un bit, numit bit de intensitate/alpha, celor 3 pentru fiecare canal de culoare (avem deci 4 biti per pixel, rezultand 200x150x4 biti de memorie, respectiv 8 blocuri de RAM static a 16Kb fiecare pentru implementare). Acest bit determina cat de "luminioasa" este reprezentarea pixelului pe monitor. Pixelii cu alpha setat la 0 sunt considerati "intunecati", iar cei cu alpha setat la 1 sunt considerati "luminosi". Acest truc merge deoarece fiecare pixel din framebuffer este reprezentat de o zona de 4x4 pixeli pe monitor. Pixelii luminosi sunt desenati colorand cu culoare respectiva toata regiunea, iar cei intunecati sunt desenati colorand doar o patrime din pixeli (cei de la coordonatele (0,0), (0,2), (2,0) si (2,2) din regiunea de 4x4), pe restul lasandu-i negri.

[Imagine monitor cu dungi de culori]

Ca si implementare, aceata este cea mai sofisticata componenta de pana acum. Contine trei module ce opereaza in paralel. Primul este cel de interfata cu secventiatorul. Acesta accepta comenzi prin portul de comanda, le interpreteaza si controleaza celelalte doua module. Al doilea modul este cel de acces la framebuffer. Este reprezentat de un banc de 8 memorii de 16 Kb, fiecare avand doua porturi de citire si unul de scriere ce opereaza in paralel. Portul de citire este folosit pentru accesarea memoriei pentru desenare, iar cel de scriere pentru inscrierea de date de la secventiator. Cel din urma modul este cel de control VGA propriu-zis. Acesta genereaza semnalele de control pentru dispozitivele VGA cat si semnale de acces la memorie pentru citirea pixelului de desenat curent.

[Imagine unitatea de control VGA high|low].

[Tabel instructiuni]

Aceasta componenta nu are porturi de iesire spre secventiator, doar un bloc de interfata cu pinii asociati traseelor spre portul VGA.

[Imagine componenta conectata la un secventiator].

3.2.2.9.Unitatea de control DDR.

Aceasta este de departe cea mai sofisticata componenta realizata, si poate cea mai mare din intreg proiectul. Este de asemenea si singura care merge doar in simulator. Componenta in sine implementeaza interfata de acces catre chipul de memorie DDR SDRAM Micron [whatever] de pe kit-ul de dezvoltare. 

[Poza memorie].

Componenta este alcatuita din patru module separate ce opereaza in paralel. Primul modul implementeaza interfata catre secventiator. Se ocupa de interpretat comenzi si comandat celelalte componente. Al doilea modul este activ doar pe perioada de initializare a memoriei. Memoriile DDR au un procedeu de initializare complex, ce necesita un numar de operatii intr-o ordine bine stabilita, perfect sincronizate in timp. Odata procesul de initializare completat, acest modul semnalizeaza celorlalte posibilitatea de acces la memorie. Al treilea modul se ocupa de interactiunea propriu-zisa cu memoria. Primeste comenzi de la modulul de interfata cu secventiatorul si de la ultimul modul (cel de reincarcare periodica a memoriei) si efectueaza secventa de operatiuni necesare. Ultimul modul este cel de reincarcare periodica. Acesta cere modulului de acces, din aproximativ 400 in 400 de cicluri de ceas, sa efectueze o operatie de AutoRefresh asupra memoriei. Astfel de operatii periodice sunt impuse de standardul DDR SDRAM, continutul memoriei pierzandu-se altfel (este o memorie RAM dinamica sincrona: SDRAM).

Aceasta componenta este singura la care operatiile au latente vizibile si neprevizibile. De exemplu, o operatie de scriere este interpretata de modulul de interfata cu secventiatorul, iar acesta da comanda modulului de interfata cu memoria sa porneasca o scriere. Aceasta scriere poate porni sau nu imediat. Daca modulul de acces la memorie este ocupat cu o operatie de auto-refresh, sau aceasta este comandata in acelasi timp cu operatia de scriere, atunci operatia de scriere trebuie sa astepte (avand prioritate mai mica). O scriere poate dura intre 6 si 10 ciclii de ceas in acest mod.

Scrierile si citirile dureaza mult comparat cu alte componente, si se fac in cuante de 32 de biti (o pagina de 4 octeti). Acest design este suboptim, memoriile DDR SDRAM, desi au latente mari, au posibilitati de throughput mari (in cazul nostru, memoria are o interfata de date de 16 biti, pe care se pot transmite 32 de biti per ciclu de ceas). Eu folosesc in citiri si scrieri o marime a burst-ului de operatii de 2 (adica se citesc doua cuvinte de 16 biti) pentru a se potrivii cu marimea paginii si a termina repede operatiunile. In implementari viitoare, pagina trebuie sa aiba marimi mult mai mari (eventual 16Kb : marimea unei celule ram statice din FPGA) si sa se atenueze latentele de acces prin volumul mare de scrieri/citiri din operatia de descarcare/incarcare de pagina.

[Imagine unitate de control DDR]

[Tabel instructiuni]

Aceasta componenta are 4 porturi de iesire spre secventiator, cate unul pentru fiecare octet al paginii.

[Imagine componente conectata la un secventiator + iesiri]

Vorbesc aici efectiv despre ce am făcut eu. Enumăr realizările. Apoi vorbesc despre cele doua ținte : simularea și FPGA-ul. FPGA-ul este principalul mijloc de realizare, fac un rundown al sistemului de dezvoltare, enumăr limitări, avantaje etc. Trebuie sa vorbesc cumva și despre simulare. Eventual și despre mediul de build și unelte. Apoi încep sa vorbesc despre toolkit-ul ce îl construiesc. Ce înseamna secventiator, ce înseamna componenta, cum se leagă. Ideea ca pot fi combinate în fel și chip, configurate ca sa avem un sistem optim. O sa vorbesc despre modul comun de codare a secventiatoarelor și componentelor în verilog (cu exemplu). Și apoi sa vorbesc despre interfața lor, despre faptul ca au instrucțiuni, ca vreau sa fie toată faza de high-level design, și sa ca sa fie accesul cât mai simplu. Ca sa fie un fel de standard (o magistrala comuna pe care comunica toate astea), etc. Trebuie sa vorbesc despre un exemplu de secventiator : Seq, cu caracteristicile lui, și despre ce componente am realizat pana acum. Pun accent pe grupul Core (registrii, alu, swc, etc.) pe grupul de interfața (Butoane, Rotary, VGA etc.) și pe modulul de interfața cu memoria ddr (descriu cât de greu e și aja).

Exemple de aplicații.

În final vorbesc despre aplicații. Dau exemplele Auto2, RotaryLed, BlockFall etc. cu ce fac, programe, structura lor etc. etc.

Concluzii.

TODO:

* Sa fiu mai clar : comanda : functie cu un sg argumet.
* Sa vorbesc despre instructiuni. Cod etc. Dihotomie instructiuni de control al fluxului si instructiuni de operare asupra datelor.
* Sa vorbesc despre interfata high-level oferita de componente.
* Sisteme, aplicatii.
* Schimba totul la persoana I,sg.
* discutie despre avantaje transfer.

IDEI:

* problema => sistem digital = cu setul de unelte > aplicatie
* aplicatie = nucleu+ ++ logica de interconectare
* nucleu = secventiator ++ componenta+ ++ logica de interconectare
* dihotomie : high-level view si low-level view.
* avem refolosire de componente de granularitate mica : secventiatoare si componente (functii, librarii, framework-uri etc. in lumea software) si granularitate mare (folosirea de aplicatii intregi in lumea software). Ambele au avantaje si dezavantaje.
* refolosire prin interfata comuna. IPCores nu au interfata comuna.

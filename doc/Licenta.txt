Lucrarea de licență.

Studiu asupra procesoarelor cu arhitectura de transport. Exemple de aplicații.

1.Introducere.

2.Teorie generala.

Arhitectura de Transport, alaturi de Arhitectura von Neumann si Arhitectura Harvard, este un model pentru organizarea masinilor de calcul. Majoritatea realizarilor fizice ale acestor modele au fost, istoric, sub forma calculatoarelor digitale, iar discutia ce urmeaza va fi influentata de acest fapt. Modelul clasic, si discutabil, cel mai des folosit, este cel von Neumann. Vom numi un calculator ce adopta o astfel de arhitectura, un calculator von Neumann, procedand similar pentru celelalte doua tipuri de arhitecturi.

De notat, ca toate aceste modele pornesc de la premisele implementarii unei forme de Masina Turing. Aceste masini sunt entitati matematice, folosite de matematicieni in intelegerea procesului de calculare a unei functii, proces ce in acest caz este descris de un algoritm ce opereaza asupra unui set de date. Algoritmul este codificat si trebuie interpretat de o Masina Turing pentru a produce datele de iesire pornind de la o instanta specifica de date de intrare. O Masina Turing este alcatuita dintr-o banda de celule infinita si un cap de citire/prelucrare plasat deasupra unei celule specifice. Fiecare celula are inscrisa un simbol ales dintr-un alfabet finit. Masina este caracterizata de o stare curenta aleasa dintr-un alfabet finit si un set de reguli ce asociaza perechilor [stare,simbol] actiuni, ce pot produce o modificare a starii masinii, o deplasare a capului de citire pe banda sau o schimbare a simbolului inscris in celula curenta. Regula de functionare a masinii este urmatoarea: aceasta porneste intr-o stare initiala cu capul de citire plasat deasupra unei celule initiale si trebuie sa ajunga intr-una din starile finale (sau stari acceptante). Se produce modificarea specificata de regula asociata perechii initiale iar masina isi schimba starea si afecteaza intr-un mod banda. Dupa un timp (durata pasului de executie) se executa actiunea asociata noii perechi [stare,simbol]. Procesul continua in acest fel, din pas de executie in pas de executie, pana la schimbarea intr-o stare acceptanta, moment in care se spune ca algoritmul se incheie cu succes. Un concept important este acela ca algoritmul se executa intr-un anumit timp discretizat in pasi de executie. Timpul total este determinat de durata unui pas si de numarul de pasi executati. Cu alte cuvinte, un calcul nu se executa instantaneu, ci dureaza un anumit timp. Aceasta limitare duce la un model de computabilitate ce reflecta realitatea fizica (in primul rand existenta unor variatii minime in timp si spatiu care ar impiedica, in principiu, orice masina de calcul sa execute un algoritm instantaneu, constrangand durata unui pas de executie sa fie cel mult egala cu variatia temporala minima, iar apoi, in al doilea rand, limitarile dispozitivelor actuale ce inpun o alta categorie de constrangeri, mult mai dure (ordine de marime in timp si spatiu deasupra variatiilor minime)).

Arhitectura von Neumann presupune existenta unei Unitati de Procesare (UP) ce are acces la o Unitate de Stocare (US) si la un numar de dispozitive de Intrare/Iesire (DIO). Acest model mai este cunoscut si ca "Modelul de Calculator cu Program Stocat", el presupunand existenta in US atat a datelor de intrare cat si a descrierii algoritmului ce trebuie executat. Astfel se inglobeaza in US atat banda unei Masini Turing cat si setul de reguli ce descriu algoritmul. UP este astfel o componenta generica, independenta de vreun algoritm anume, si interactioneaza cu US pentru a obtine simbolurile ce descriu operatia de executat cat si datele pe care aceasta se va executa. Desi cele doua nu se refera conceptual la aceleasi lucruri, Masina Turing fiind folosita pentru descrierea abstracta a calculelor, pe cand Arhitectura von Neumann descriind cum o masina de calcul oarecare ar putea fi structurata, exista o legatura puternica intre cele doua, o Masina von Neumann fiind o realizare generica a unei Masini Turing. Mai mult, pe cand o Masina Turing este specifica fiecarei probleme (fiind descrierea algorimtului de rezolvare), Masina von Neumann este generala, specializarea pe o problema sau alta fiind realizata de catre o configuratie anume a US.

[Poza Arhitectura von Neumann]

Dupa cum spuneam, majoritatea masinilor de calcul sunt calculatoare digitale. Unitatea de Stocare este alcatuita dintr-un grup de memorii, avand ca unitatea de stocare fundamentala bitul. O masina de calculdigitala este caracterizata de numarul de biti cu care poate opera in paralel, acest numar reprezentand marimea cuvantului. Marimi standard sunt 4,8,16,32 si 64 de biti. Conceptul abstract de simbol cu care am lucrat pana acum in definirea Masinii Turing si a Masinii von Neumann este inlocuit de cuvant, o entitate numerica, folosita atat in codarea simbolurilor cat si ca atare (ca un numar). Fiind in domeniul practic, aceasta decizie este naturala pentru ca duce la o reprezentare usoara (un cuvant de N biti este reprezentat in memorie de N celule de stocare, are nevoie de N registrii pentru stocare in interiorul Unitatii de Procesare etc. - pe cand reprezentarea unui simbol : un nume pentru o entitate matemtatica, in definitiv, produce multe nedumeriri), dar, are dezavantajul ca presupune inglobarea in UP a unei unitati pentru lucrul cu numere. Aceasta se numeste Unitatea Aritmetico-Logica si este folosita in reprezentarea clasica a Masinilor von Neumann.

[Poza Arhitectura von Neumann clasica].

Practica a impus separarea Unitatii de Procesare intr-o Unitate de Control (UC) si o Unitate Aritmetico-Logica (UAL). UC indeplineste rolul pe care UP il indeplinea in modelul abstract, anume, aduce din US comenzi si date sub forma simbolica sau numerica, le interpreteaza, operand apoi schimbarile inapoi asupra US. Pentru as-i duce la bun sfarsit operatiile, UC face apel la UAL, multe dintre instructiunile unui calculator (si implicit, operatiile pe care le poate efectua) avand natura aritmetica.

Calculatoarele moderne pornesc de la acest model, adaugand diverse componente si extinzand modelul de baza, in principiu pentru a face fata problemelor lumii fizice. Un calculator actual personal poate avea urmatoarea structura (la un nivel foarte inalt).

[Poza Arithectura calculator clasica].

O observatie rapida ar fi ca pentru majoritatea programelor nu este nevoie decat de acces de citire la regiune de memorie in care este stocat codul programului (codificarea algoritmului). Pornind de la aceasta observatie, o alternativa la Arhitectura von Neumann este Arhitectura Harvard. Conceptual, presupune doar separarea US intr-o Unitate de Stocare pentru Program (USP) si o Unitate de Stocare pentru Date (USD), pastrand in rest caracteristicile von Neumann. Principalul avantaj al unei astfel de abordari este o crestere in viteza cauzata de separarea cailor fizice de transmisie intre UP si US in doua cai UP - USP si UP - USD. Se pot face accese la instructiuni concomitent cu accese de date, lucru foarte util in cazul foarte comun in care viteza de acces la memorie este mica (si deci nu exista dorinta de a avea multe accese spre acceasi memorie, ci multe accese spre memorii diferite). Mai mult, pentru multe aplicatii, programul ocupa un spatiu mult mai mic decat datele. Memoria necesara stocarii lui este mai mica, si poate fi situat mai aproape in ierarhia memoriilor de UP (poate chiar in acelasi microprocesor in care este gazduit si UP). In practica, multe dintre procesoarele construite pe baza arhitecturii von Neumann adopta principii Harvard, exemplul cel mai elocvent fiind existenta memoriilor cache separate pentru program si date aproape de UP, dar unificarea lor in memoria principala (si mentinerea iluziei unificarii).

[Poza Arhitectura calculator Harvard].

[Poza Arhitectura calculator modern evidentiand locurile unde e Harvard].

In spatiul modelelor pentru masini de calcul, Arhitecturile de Transport se situeaza undeva deasupra celor studiate pana acum. Intr-adevar, vom vedea ca arhiecturile de transport sunt folosite pentru structurarea sitemelor digitale in general, acest lucru neimplicand neaparat echivalenta sistemului cu o Masina Turing. Cateva dintre exemplele de aplicatii nu vor fi universale in acest sens.

Ce inseamna atunci, ca un calculator este o Masina de Transport? Pornind tot de la o Masina von Neumann, acest lucru presupune eliminarea UAL ca si unitate privilegiata. Din UP ramane doar partea de control (UC) alaturi de US. ALU este trecut in categoria dispozitivelor externe (DIO). Mai mult, asemeni masinilor Harvard, se adopta o separare a memoriei de program si a memoriei de date. USD trece alaturi de ALU in categoria dispozitivelor de iesire, iar USP ramane alaturi de UC ca unitate distincta. Astfel avem o stransa cuplare intre UP si USP si o cuplare intre UP si DIO. UP interactioneaza cu USP pentru obtinerea instructiunilor de control iar 

[Poza Arhitectura de Transport].

Ce ramane atunci efectiv din masina de calcul este un sistem programat ce controleaza transferurile intre unitati externe. Unitatile externe pot lua orice forma si pot fi combinate in orice fel. De aici si flexbilitatea de a face un sistem mai apropiat de cerintele aplicatiei. Depinzand de selectia de componente externe, sistemul poate si sau nu universal, dupa cum am mentionat.

[Poza Arhitectura de Transport #2]

Putem spune ca din setul de instructiuni ale unui calculator, intr-un astfel de sistem pastram doar instructiunile de control. Instructiunile artimetico-logice sunt elimiate, functiile lor realizandu-se de unitati externe. Instructiunea de baza este cea de control al transferului : aceasta spune ca la un pas de executie, continutul de la o intrare a UP sa fie transmis catre o iesire. Este singura instructiune necesara (este un exemplu de One Instruction Set Computer), pana si contorul de program putand fi reprezentat ca o componenta externa. Complexitatea ei variaza, putand fi conditionata de valoarea unei intrari sau a datei de transmis [1] sau putand specifica mai multe transferuri de efectuat in paralel.

Componentele externe joaca si ele un rol important. Ele isi efectueaza operatiile ca urmare a primirii unui transfer de la UP. Acesta este modul de programare. UP coordoneaza transferuri intre unitati. Datele primite de o componenta la intrare sunt procesate si prezentate la iesire, iar rezultatul este transferat catre intrarea unei alte componente samd. Dintre acestea enumeram : bancuri de registrii, numaratoare, dispozitive de interfata seriala/paralela, timere, memorii, interfete cu diverse componente externe calculatorului etc.

3.Prezentarea sistemului. Descriere componente. Unelte.

Din punct de vedere practic, am realizat un set de unelte pentru constructia de aplicatii dedicate, sub forma unor sisteme inspirate din ideile Arhitecturilor de Transfer. Exista un numar de diferente pe care le voi evidentia la momentul potrivit, dar sistemele astfel construite au anumite elemente imprumutate de la arhitecturile clasice, introduse pentru a face dezvoltarea aplicatiilor mai usoara. In jargonul de pana acum, am definit un numar de UC si DIO, cat si o metoda standard de dezvoltare si de interconectare, ce sunt asamblate, in functie de cerintele aplicatiei, in sisteme. Am numit UC-urile Secventiatoare (pentru ca ele controleaza secventa de operatiuni efectuate) si DIO-urile Componente. In plus, am dezvoltat un numar de sistme auxiliare, utile in procesul de constructie. Printre acestea se numara un asamblor pentru secventiatoare si un generator de memorii. Acestea au asociate formate de configurare si de program sursa specifice, pe care le voi documenta in subcapitolele aferente. De mare importanta este si sistemul de construire propriu-zisa a sistemului, ce poate crea "binare" atat pentru sistemul de dezvoltare cat si pentru simulare.

Inainte de a intra in amanunte, trebuie sa facem un mic ocol si sa vorbesc despre sistemul de dezvoltare. Acesta este un kit [nume kit aici] produs de firma Digillent. Componente principale sunt un chip FPGA Spartan3E [descriere tehnica] produs de Xilinx, o memorie DDR SDRAM [tip] Micron, o iesire VGA si un display LCD text [spune marca aici]. Sistemul mai ofera un numar de butoane si controale fizice, doua porturi seriale, porturi PS/2, convertoare analog-digital si digital-analog cat si pini de extensie. Un ceas cristal ce genereaza un ceas de 50Mhz este de asemenea folosit. Toate sistemele vor opera la aceasta frecventa. Chip-ul FPGA este folosit pentru integrarea propriu-zisa a sistemelor. Design-ul unui sistem pentru o aplicatie presupune determinarea secventiatoarelor si componentelor folosite, determinarea unei metode de interconectare si de acces la ceasuri, scrierea programelor de control si legarea componentelor la lumea externa. Sitemul de constructie ia apoi aceasta descriere si o transforma, folosind unelte puse la dispozitie de realizatorul chip-ului FPGA, intr-un forma acceptabila pentru incarcarea pe kit. Odata incarcat, sistemul incepe executia si poate raspunde la comenzi ale utilizatorului sau interactiona cu acesta in alte moduri.

Elementul central este chip-ul FPGA. El este caracterizat de prezenta a 9000~ celule logice programabile de 4 intrari, 4000 de registrii de un bit, 20 de memorii SRAM de 16Kb, 4 unitati de management al ceasului si [multe] porturi de iesire conectate la componentele "periferice".

[poza kit dezvoltare]

In centrul ierarhiei de componente se afla Secventiatoarele. Acestea sunt in esenta automate programate, ce au un numar de intrari si iesiri generice, pentru interactiunea cu elemente comandate. Acestea pot fi Componente (de obicei) sau alte Secventiatoare. Atasat de un secventiator este o sursa de program. Momentam am folosit doar memorii ROM mici drept sursa. Sistemul este deajuns de flexibil incat secventiatoarele actuale pot folosii atat memorii SRAM integrate in FPGA cat si memorii externe (in cazul nostru memoria DDR SDRAM externa, la care se ajunge printr-o componenta specializata de interfata, datorita protocolului complicat de comunicare) etc. Un Secventiator este implementat ca un circuit digital folosind FPGA-ul.

[poza Secventiator in centrul unui sistem]

Componentele sunt dispoztive cu functii clare. Exemple de componente sunt unitati aritmetico-logice, bancuri de registrii, timere si cronometre, memorii RAM si memorii ROM si, nu in ultimul rand, module intregi si sofisticate de interfata cu lumea externa (VGA,PS/2,serial,paralel,Ethernet,SDRAM etc.). Componentele sunt implementate ca circuite digitale folosind FPGA-ul. Ele pot avea si acces la lumea exterioara prin legarea lor la pini de comunicare externa (care sunt mapati dinspre FPGA inspre intrari fixe ale componentelor periferice). 

Exista si legaturile intre circuitele realizate, ce apar in interiorul chipului FPGA sub forma de trasee a caror configuratie este determinata de software-ul de transformare specific platformei. Ele vor aparea explicit (ca in cazul Secventiatorului si a Componentelor) unde sunt numite magistrale de comunicatie si au rolul de a transmite comenzi de la secventiator catre componente si rezultate de la componente catre secventiator, sau pot fi ascunse, vizibile doar celui care scrie propriu-zis sistemul (de exemplu, legaturi interne in componente).

Secventiatorul este caracterizat de un numar de porturi de intrare si iesire, iar componentele de un port de comanda si mai multe porturi de iesire. Din punct de vedere al interconectarii de nivel-inalt (la nivel de magistrala) acestea sunt singurele moduri in care se conecteaza sistemele. Cum am spus si mai sus, in realitate exista o multitudine de semnale ce trebuiesc plasate (semnale de ceas de diferite faze, semnale de reset, toate semnalele catre lumea exterioara etc.). Cand vorbim de porturi si magistrale, ne vom referii in general la descriptia aceasta de nivel inalt, abstracta, si ignoram detaliile de implementare (si faptul ca in realitate, la un anumit nivel, sistemele chiar sunt alcatuite din componente cu un numar de porturi expuse, si magistrale de interconectare).

Portul de comanda al unei componente se leaga la un port de iesire al secventiatorului iar pe magistrala dintre cele doua se transmit comenzile. Formatul portului este comun tuturor componentelor. O parte este un cuvant de comanda, iar alta parte este argumentul comenzii. Semnificatia si formatul argumentului este determinat de tipul de comanda. Diverse porturi de iesire ale componentelor se pot lega ca intrari in secventiator. De exemplu, una dintre componentele ce vor fi prezentate implementeaza o unitate aritmetico-logica simpla. Ea are portul de comanda standard si un port de rezultat. Acesta se leaga la intrearea in secventiator, iar acesta are acces la rezultatul operatiilor comandate. Caracteristice pentru o componenta sunt marimea cuvantului de comanda (determina cate comenzi distincte se pot efectua) si marimea argumentului. Acestea determina si posibilitatile de interconectare (nu este indicat sa conectezi un secventiator la o componenta, cand acestea au marimi ale cuvantului, respectiv argumentului, diferite).

[Imagine componenta si prezentare hw]

Caracteristici ale secventiatorului sunt marimea cuvantului, marimea spatiului de adrese, numarul de porturi de intrare si iesire, marimea portiunii de comanda din instructiune si marimea instructiunii propriu-zisa. Acestea impreuna cu setul de instructiuni descriu in mare parte un secventiator. Acesta opereaza dupa modelul traditional al unui microprocesor. La fiecare pas de executie (pasii de executie sunt dictati de ceasul sistemului) extrage instructiunea curenta din memoria de program (aceasta este determinata de adresa instructiunii curente, o parte din starea unui secventiator, dar nu numai), o decodeaza si executa fie transferurile codate, fie operatia de control (un salt sau o asteptare). Acestea sunt operatiile comune, dar setul de instructiuni, ca si parametrii de mai sus sunt specifici unei instante anume de secventiator, si in functie de situatie, pot fi instructiuni variate.

[Imagine secventiator si prezentare modul hw]

Vorbesc aici efectiv despre ce am făcut eu. Enumăr realizările. Apoi vorbesc despre cele doua ținte : simularea și FPGA-ul. FPGA-ul este principalul mijloc de realizare, fac un rundown al sistemului de dezvoltare, enumăr limitări, avantaje etc. Trebuie sa vorbesc cumva și despre simulare. Eventual și despre mediul de build și unelte. Apoi încep sa vorbesc despre toolkit-ul ce îl construiesc. Ce înseamna secventiator, ce înseamna componenta, cum se leagă. Ideea ca pot fi combinate în fel și chip, configurate ca sa avem un sistem optim. O sa vorbesc despre modul comun de codare a secventiatoarelor și componentelor în verilog (cu exemplu). Și apoi sa vorbesc despre interfața lor, despre faptul ca au instrucțiuni, ca vreau sa fie toată faza de high-level design, și sa ca sa fie accesul cât mai simplu. Ca sa fie un fel de standard (o magistrala comuna pe care comunica toate astea), etc. Trebuie sa vorbesc despre un exemplu de secventiator : Seq, cu caracteristicile lui, și despre ce componente am realizat pana acum. Pun accent pe grupul Core (registrii, alu, swc, etc.) pe grupul de interfața (Butoane, Rotary, VGA etc.) și pe modulul de interfața cu memoria ddr (descriu cât de greu e și aja).

Exemple de aplicații.

În final vorbesc despre aplicații. Dau exemplele Auto2, RotaryLed, BlockFall etc. cu ce fac, programe, structura lor etc. etc.

Concluzii.

TODO:

* Sa vorbesc despre instructiuni. Cod etc. Dihotomie instructiuni de control al fluxului si instructiuni de operare asupra datelor.
* Sisteme, aplicatii.
* Schimba totul la persoana I,sg.

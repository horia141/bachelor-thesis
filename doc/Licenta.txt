Lucrarea de licență.

Studiu asupra procesoarelor cu arhitectura de transport. Exemple de aplicații.

1.Introducere.

2.Teorie generala.

Arhitectura de Transport, alaturi de Arhitectura von Neumann si Arhitectura Harvard, este un model pentru organizarea masinilor de calcul. Majoritatea realizarilor fizice ale acestor modele au fost, istoric, sub forma calculatoarelor digitale, iar discutia ce urmeaza va fi influentata de acest fapt. Modelul clasic, si discutabil, cel mai des folosit, este cel von Neumann. Vom numi un calculator ce adopta o astfel de arhitectura, un calculator von Neumann, procedand similar pentru celelalte doua tipuri de arhitecturi.

De notat, ca toate aceste modele pornesc de la premisele implementarii unei forme de Masina Turing. Aceste masini sunt entitati matematice, folosite de matematicieni in intelegerea procesului de calculare a unei functii, proces ce in acest caz este descris de un algoritm ce opereaza asupra unui set de date. Algoritmul este codificat si trebuie interpretat de o Masina Turing pentru a produce datele de iesire pornind de la o instanta specifica de date de intrare. O Masina Turing este alcatuita dintr-o banda de celule infinita si un cap de citire/prelucrare plasat deasupra unei celule specifice. Fiecare celula are inscrisa un simbol ales dintr-un alfabet finit. Masina este caracterizata de o stare curenta aleasa dintr-un alfabet finit si un set de reguli ce asociaza perechilor [stare,simbol] actiuni, ce pot produce o modificare a starii masinii, o deplasare a capului de citire pe banda sau o schimbare a simbolului inscris in celula curenta. Regula de functionare a masinii este urmatoarea: aceasta porneste intr-o stare initiala cu capul de citire plasat deasupra unei celule initiale si trebuie sa ajunga intr-una din starile finale (sau stari acceptante). Se produce modificarea specificata de regula asociata perechii initiale iar masina isi schimba starea si afecteaza intr-un mod banda. Dupa un timp (durata pasului de executie) se executa actiunea asociata noii perechi [stare,simbol]. Procesul continua in acest fel, din pas de executie in pas de executie, pana la schimbarea intr-o stare acceptanta, moment in care se spune ca algoritmul se incheie cu succes. Un concept important este acela ca algoritmul se executa intr-un anumit timp discretizat in pasi de executie. Timpul total este determinat de durata unui pas si de numarul de pasi executati. Cu alte cuvinte, un calcul nu se executa instantaneu, ci dureaza un anumit timp. Aceasta limitare duce la un model de computabilitate ce reflecta realitatea fizica (in primul rand existenta unor variatii minime in timp si spatiu care ar impiedica, in principiu, orice masina de calcul sa execute un algoritm instantaneu, constrangand durata unui pas de executie sa fie cel mult egala cu variatia temporala minima, iar apoi, in al doilea rand, limitarile dispozitivelor actuale ce inpun o alta categorie de constrangeri, mult mai dure (ordine de marime in timp si spatiu deasupra variatiilor minime)).

Arhitectura von Neumann presupune existenta unei Unitati de Procesare (UP) ce are acces la o Unitate de Stocare (US) si la un numar de dispozitive de Intrare/Iesire (DIO). Acest model mai este cunoscut si ca "Modelul de Calculator cu Program Stocat", el presupunand existenta in US atat a datelor de intrare cat si a descrierii algoritmului ce trebuie executat. Astfel se inglobeaza in US atat banda unei Masini Turing cat si setul de reguli ce descriu algoritmul. UP este astfel o componenta generica, independenta de vreun algoritm anume, si interactioneaza cu US pentru a obtine simbolurile ce descriu operatia de executat cat si datele pe care aceasta se va executa. Desi cele doua nu se refera conceptual la aceleasi lucruri, Masina Turing fiind folosita pentru descrierea abstracta a calculelor, pe cand Arhitectura von Neumann descriind cum o masina de calcul oarecare ar putea fi structurata, exista o legatura puternica intre cele doua, o Masina von Neumann fiind o realizare generica a unei Masini Turing. Mai mult, pe cand o Masina Turing este specifica fiecarei probleme (fiind descrierea algorimtului de rezolvare), Masina von Neumann este generica, specializarea pe o problema sau alta fiind realizata de catre o configuratie anume a US.

[Trebuie sa vorbesc de Unitatea de control si Unitatea aritmetica si cum toate chestiile sunt numere ptr. calculatoare digitale si d'asta tot apar ce apar].

Arhitectura Harvard este similara celei von Neumann. Diferenta majora consta in faptul ca exista o separatie a US intr-o Unitate de Stocare pentru Program (USP) si o Unitate de Stocare de Date, ce stocheaza algoritmul, respectiv, datele problemei. UPS are in general restrictii de scriere impuse de practica.

Majoritatea realizarilor actuale de masini de calcul sunt calculatoare digitale ce se situeaza undeva pe spectrul intre o Masina von Neumann si o Masina Harvard pura. Majoritatea realizarilor de Masini von Neumann sunt calculatoare digitale, UP fiind reprezentat actual de microprocesor, US de catre o ierarhie de memorii (unele dintre ele integrate in microprocesor), iar DIO de multitudinea de dispozitive de intrare iesire si infrastructura de conectare a lor la microprocesor.

3.Prezentarea sistemului. Descriere componente. Unelte.

Vorbesc aici efectiv despre ce am făcut eu. Enumăr realizările. Apoi vorbesc despre cele doua ținte : simularea și FPGA-ul. FPGA-ul este principalul mijloc de realizare, fac un rundown al sistemului de dezvoltare, enumăr limitări, avantaje etc. Trebuie sa vorbesc cumva și despre simulare. Eventual și despre mediul de build și unelte. Apoi încep sa vorbesc despre toolkit-ul ce îl construiesc. Ce înseamna secventiator, ce înseamna componenta, cum se leagă. Ideea ca pot fi combinate în fel și chip, configurate ca sa avem un sistem optim. O sa vorbesc despre modul comun de codare a secventiatoarelor și componentelor în verilog (cu exemplu). Și apoi sa vorbesc despre interfața lor, despre faptul ca au instrucțiuni, ca vreau sa fie toată faza de high-level design, și sa ca sa fie accesul cât mai simplu. Ca sa fie un fel de standard (o magistrala comuna pe care comunica toate astea), etc. Trebuie sa vorbesc despre un exemplu de secventiator : Seq, cu caracteristicile lui, și despre ce componente am realizat pana acum. Pun accent pe grupul Core (registrii, alu, swc, etc.) pe grupul de interfața (Butoane, Rotary, VGA etc.) și pe modulul de interfața cu memoria ddr (descriu cât de greu e și aja).

Exemple de aplicații.

În final vorbesc despre aplicații. Dau exemplele Auto2, RotaryLed, BlockFall etc. cu ce fac, programe, structura lor etc. etc.

Concluzii.

